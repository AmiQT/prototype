"""Coordinator for AI assistant commands."""

from __future__ import annotations

import json
import logging
from datetime import date, datetime, timedelta
from typing import Any

from fastapi import Depends
from sqlalchemy.orm import Session

from app.database import get_db
from . import schemas, logger as ai_logger, permissions
from .config import AISettings, get_ai_settings
from .openrouter_client import OpenRouterClient
from .service_bridge import AssistantServiceBridge
from .supabase_bridge import SupabaseAIBridge
from .admin_db_assistant import AdminDatabaseAssistant

log = logging.getLogger(__name__)


class AIAssistantManager:
    """Main entry point for handling AI commands via OpenRouter."""

    def __init__(self, settings: AISettings = Depends(get_ai_settings), db: Session = Depends(get_db)) -> None:
        self.settings = settings
        self.daily_usage = 0  # basic in-memory counter (future: persist/cache)
        self._usage_date = date.today()
        self._openrouter_client: OpenRouterClient | None = None
        self._service_bridge = AssistantServiceBridge(db=db)
        self._supabase_bridge = SupabaseAIBridge()
        self._admin_db_assistant = AdminDatabaseAssistant(db=db)

    async def handle_command(
        self,
        command: str,
        context: dict[str, Any] | None = None,
        current_user: dict[str, Any] | None = None,
    ) -> schemas.AICommandResponse:
        """Process command using OpenRouter (direct agentic mode)."""

        log.info("🤖 AI ASSISTANT: Received command: '%s'", command)
        log.info("🔍 Current user: %s", current_user.get("email") if current_user else "anonymous")

        self._reset_usage_if_needed()

        if not self.settings.ai_enabled:
            response = schemas.AICommandResponse(
                success=False,
                message="AI assistant is disabled.",
                source=schemas.AISource.MANUAL,
                data={},
            )
            ai_logger.log_ai_action(current_user.get("uid"), command, response.model_dump())
            return response

        if not permissions.can_run_action(current_user or {}, "general"):
            response = schemas.AICommandResponse(
                success=False,
                message="You do not have permission to run AI actions.",
                source=schemas.AISource.MANUAL,
                data={},
                fallback_used=True,
            )
            ai_logger.log_ai_action(current_user.get("uid"), command, response.model_dump())
            return response

        # Try to handle with local agentic actions first (database queries)
        log.info("🔧 Trying local agentic actions first...")
        local_response = await self._try_local_agentic_action(command, current_user)
        if local_response:
            log.info("✅ Local agentic action handled the command successfully!")
            ai_logger.log_ai_action(
                current_user.get("uid") if current_user else "anonymous",
                command,
                local_response.model_dump(),
            )
            return local_response
        else:
            log.info("❌ No local agentic action found, proceeding to OpenRouter...")

        # Direct ke OpenRouter bila available
        if self.settings.enable_openrouter and self.settings.openrouter_api_key:
            if self.daily_usage >= self.settings.openrouter_daily_limit:
                log.warning("OpenRouter quota reached for the day")

            response = await self._call_openrouter(command, context)
            if response:
                        self.daily_usage += 1
                        ai_logger.log_ai_action(
                            current_user.get("uid") if current_user else "anonymous",
                            command,
                            response.model_dump(),
                        )
                        return response

        log.info("Rate limit reached, will use casual fallback response")

        # Natural fallback responses (no mention of technical issues)
        if any(word in command.lower() for word in ["hai", "hello", "hi"]):
            casual_msg = "Hai! 😊 Apa khabar? Saya AI assistant untuk UTHM dashboard, siap sedia nak tolong!"
        elif any(word in command.lower() for word in ["siapa", "nama"]):
            casual_msg = "Saya AI assistant untuk dashboard UTHM! 😄 Nama saya belum ada lagi, tapi panggil je 'Assistant' atau 'AI'. Ada apa yang boleh saya tolong?"
        elif "apa khabar" in command.lower():
            casual_msg = "Khabar baik! 😊 Tengah standby nak tolong dengan apa-apa yang awak perlukan. Awak macam mana hari ni?"
        elif any(word in command.lower() for word in ["help", "tolong", "bantuan"]):
            casual_msg = "Sure! 💪 Saya sedia tolong. Apa yang awak perlukan? Boleh tanya tentang sistem UTHM, dashboard features, atau apa-apa je!"
        elif any(word in command.lower() for word in ["terima kasih", "thanks", "thank you"]):
            casual_msg = "Sama-sama! 😊 Senang dapat tolong. Ada apa-apa lagi yang perlukan bantuan?"
        elif "bye" in command.lower() or "selamat tinggal" in command.lower():
            casual_msg = "Bye! 👋 Take care, dan jangan segan nak tanya kalau ada apa-apa lagi ya!"
        else:
            # Generic friendly response
            casual_msg = "Hi! 😊 Saya AI assistant UTHM siap sedia tolong. Walaupun saya tak dapat proses secara mendalam sekarang, tapi boleh chat dan bagi info umum. Ada apa yang nak tanya?"

        response = schemas.AICommandResponse(
            success=True,  # Make it success so UI shows friendly message
            message=casual_msg,
            source=schemas.AISource.OPENROUTER,
            data={"status": "quota_reached", "mode": "casual_fallback"},
            fallback_used=True,
        )
        response = self._attach_quota(response)
        ai_logger.log_ai_action(current_user.get("uid") if current_user else "anonymous", command, response.model_dump())
        return response

    async def _try_local_agentic_action(
        self,
        command: str,
        current_user: dict[str, Any] | None,
    ) -> schemas.AICommandResponse | None:
        """Try to handle command with local agentic actions using real data."""
        
        command_lower = command.lower()
        
        # Student count queries - NOW WITH CONVERSATIONAL RESPONSES!
        if any(keyword in command_lower for keyword in ["berapa", "jumlah", "count", "total"]) and any(keyword in command_lower for keyword in ["pelajar", "student", "mahasiswa"]):
            log.info("🎯 DETECTED: Student count query!")
            try:
                stats = self._service_bridge.get_system_stats()
                student_count = stats.get('user_breakdown', {}).get('students', 0)
                
                # Natural conversational responses based on query
                if "fsktm" in command_lower or "computer science" in command_lower:
                    message = f"Ada {student_count} pelajar dalam sistem UTHM! 👨‍🎓 Tapi untuk specific FSKTM/Computer Science, aku perlu access detailed department data dulu. Overall profile completion rate semua pelajar adalah {stats.get('profile_completion_rate', 0)}% - quite impressive! 📈"
                elif "berapa" in command_lower:
                    message = f"Sekarang ada {student_count} pelajar yang registered dalam sistem UTHM! 🎉 Good news - semua {student_count} pelajar dah complete their profiles (100% completion rate). System kita ada total {stats.get('total_users', 0)} users including lecturers dan admins jugak. 😊"
                else:
                    message = f"Based on latest data, sistem UTHM ada {student_count} pelajar yang active! 📊 Profile completion rate pun excellent - {stats.get('profile_completion_rate', 0)}%. Kira semua students engaged dengan platform ni! 💪"
                
                return schemas.AICommandResponse(
                    success=True,
                    message=message,
                    source=schemas.AISource.OPENROUTER,  # Use OpenRouter source for consistency
                    data={
                        "student_count": student_count,
                        "total_users": stats.get('total_users', 0),
                        "profile_completion_rate": stats.get('profile_completion_rate', 0),
                        "activity_stats": stats.get('activity_stats', {}),
                        "conversational_response": True
                    },
                    steps=[schemas.AICommandStep(label="Smart Database Query", detail="Retrieved live student data and generated natural response")]
                )
            except Exception as e:
                log.error(f"Error getting student count: {e}")
                return None

        # Department analytics
        if any(keyword in command_lower for keyword in ["jabatan", "department", "fakulti", "faculty"]):
            try:
                stats = self._service_bridge.get_system_stats()
                dept_distribution = stats.get('department_distribution', {})
                
                dept_info = []
                for dept, count in dept_distribution.items():
                    dept_info.append(f"- {dept}: {count} pelajar")
                
                message = f"Taburan pelajar mengikut jabatan:\n" + "\n".join(dept_info)
                
                return schemas.AICommandResponse(
                    success=True,
                    message=message,
                    source=schemas.AISource.OPENROUTER,
                    data={
                        "department_distribution": dept_distribution,
                        "total_departments": len(dept_distribution)
                    },
                    steps=[schemas.AICommandStep(label="Department Analytics", detail="Retrieved department distribution from database")]
                )
            except Exception as e:
                log.error(f"Error getting department analytics: {e}")
                return None

        # System overview queries - NOW CONVERSATIONAL!
        if any(keyword in command_lower for keyword in ["sistem", "system", "overview", "ringkasan", "dashboard"]):
            try:
                stats = self._service_bridge.get_system_stats()
                
                students = stats.get('user_breakdown', {}).get('students', 0)
                lecturers = stats.get('user_breakdown', {}).get('lecturers', 0)
                admins = stats.get('user_breakdown', {}).get('admins', 0)
                events = stats.get('activity_stats', {}).get('events', 0)
                total = stats.get('total_users', 0)
                completion = stats.get('profile_completion_rate', 0)
                
                message = f"""Eh, system overview UTHM? Sure! 😊 Let me break it down for you:

Kita ada total **{total} users** yang active dalam platform ni! 🎉 
- **{students} pelajar** (majority lah, as expected!)
- **{lecturers} pensyarah** (our awesome educators! 👨‍🏫)  
- **{admins} admin** (keeping everything running smooth)

Activity wise, quite happening jugak! Ada **{events} events** yang terjadual dalam system. Achievements & showcase features masih dalam development phase.

Yang paling impressive - **{completion}% profile completion rate**! 🔥 Meaning semua users engaged dan dah complete their profiles. That's fantastic engagement!

Overall, platform ni healthy dan active. Students & lecturers semua engaged! 💪"""
                
                return schemas.AICommandResponse(
                    success=True,
                    message=message,
                    source=schemas.AISource.OPENROUTER,
                    data=stats,
                    steps=[schemas.AICommandStep(label="System Overview", detail="Retrieved comprehensive system statistics")]
                )
            except Exception as e:
                log.error(f"Error getting system overview: {e}")
                return None

        # ADMIN DATABASE ASSISTANT - Clean implementation!
        admin_db_response = await self._admin_db_assistant.handle_admin_query(command, current_user)
        if admin_db_response:
            return admin_db_response

        return None  # No local action found

    async def _call_openrouter(
        self,
        command: str,
        context: dict[str, Any] | None,
    ) -> schemas.AICommandResponse | None:
        """Call OpenRouter for AI responses"""
        if not db_intent:
            return None
        
        log.info("📊 Parsed admin intent: %s", db_intent)
        
        try:
            # Execute using MCP Supabase
            result = await self._execute_admin_query(db_intent)
            
            # Format for admin consumption
            return self._format_admin_db_response(result, command)
            
        except Exception as e:
            log.error(f"Admin database query error: {e}")
            return schemas.AICommandResponse(
                success=False,
                message=f"❌ Database query failed: {str(e)}",
                source=schemas.AISource.MANUAL,
                data={"error": str(e), "admin_query": True}
            )

    def _parse_admin_db_intent(self, command: str) -> dict[str, Any] | None:
        """Convert admin natural language to database operations"""
        command_lower = command.lower()
        
        # Student queries
        if any(word in command_lower for word in ["students", "pelajar", "student"]):
            if any(word in command_lower for word in ["incomplete", "tak lengkap", "not complete"]):
                return {"type": "incomplete_profiles", "table": "students"}
            elif any(word in command_lower for word in ["show", "list", "tunjuk"]):
                return {"type": "student_list", "filters": self._extract_student_filters(command_lower)}
            elif any(word in command_lower for word in ["inactive", "tak login", "not login"]):
                return {"type": "inactive_students", "days": self._extract_days(command_lower)}
        
        # Event queries
        elif any(word in command_lower for word in ["events", "acara", "event"]):
            if any(word in command_lower for word in ["upcoming", "akan datang"]):
                return {"type": "upcoming_events"}
            elif any(word in command_lower for word in ["bulan", "month", "monthly"]):
                return {"type": "monthly_events", "month": "current"}
            elif any(word in command_lower for word in ["popular", "favorite"]):
                return {"type": "popular_events"}
            elif any(word in command_lower for word in ["list", "show", "tunjuk"]):
                return {"type": "event_list", "filters": {}}
        
        # System analytics
        elif any(word in command_lower for word in ["analytics", "analisis", "performance"]):
            return {"type": "system_analytics"}
        
        # Department queries  
        elif any(word in command_lower for word in ["department", "jabatan", "fakulti"]):
            return {"type": "department_stats"}
        
        return None
    
    def _extract_student_filters(self, command: str) -> dict[str, Any]:
        """Extract filters from student query"""
        filters = {}
        
        # Department filter
        if "fsktm" in command:
            filters["department"] = "FSKTM"
        elif "fkee" in command:
            filters["department"] = "FKEE"
        elif "fkm" in command:
            filters["department"] = "FKM"
        
        # Active status
        if "active" in command:
            filters["is_active"] = True
        elif "inactive" in command:
            filters["is_active"] = False
            
        return filters
    
    def _extract_days(self, command: str) -> int:
        """Extract number of days from command"""
        import re
        
        # Look for numbers followed by "day" or "hari"
        match = re.search(r'(\d+)\s*(?:day|hari)', command)
        if match:
            return int(match.group(1))
        
        # Default patterns
        if "minggu" in command or "week" in command:
            return 7
        elif "bulan" in command or "month" in command:
            return 30
        
        return 30  # Default 30 days

    async def _execute_admin_query(self, db_intent: dict[str, Any]) -> dict[str, Any]:
        """Execute database query using MCP Supabase tools"""
        
        query_type = db_intent["type"]
        
        if query_type == "student_list":
            # Get student list with optional filters
            filters = db_intent.get("filters", {})
            
            base_query = "SELECT u.name, u.email, u.department, u.student_id, u.created_at, u.is_active FROM users u WHERE u.role='student'"
            
            if filters.get("department"):
                base_query += f" AND u.department = '{filters['department']}'"
            if filters.get("is_active") is not None:
                base_query += f" AND u.is_active = {filters['is_active']}"
            
            base_query += " ORDER BY u.created_at DESC LIMIT 50"
            
            # Execute using MCP Supabase
            result = await self._execute_mcp_sql(base_query)
            
            return {"type": "student_list", "data": result, "filters": filters}
        
        elif query_type == "incomplete_profiles":
            # Students with incomplete profiles
            query = """
                SELECT u.name, u.email, u.department, u.created_at, u.student_id
                FROM users u 
                LEFT JOIN profiles p ON u.id = p.user_id 
                WHERE u.role='student' AND (p.is_profile_complete = false OR p.id IS NULL)
                ORDER BY u.created_at DESC
            """
            
            from app.ai_assistant.manager import mcp_supabase_execute_sql
            result = await mcp_supabase_execute_sql(query)
            
            return {"type": "incomplete_profiles", "data": result}
        
        elif query_type == "inactive_students":
            # Students who haven't logged in for X days
            days = db_intent.get("days", 30)
            query = f"""
                SELECT u.name, u.email, u.department, u.last_login_at
                FROM users u 
                WHERE u.role='student' 
                AND (u.last_login_at < NOW() - INTERVAL '{days} days' OR u.last_login_at IS NULL)
                ORDER BY u.last_login_at DESC NULLS LAST
            """
            
            from app.ai_assistant.manager import mcp_supabase_execute_sql
            result = await mcp_supabase_execute_sql(query)
            
            return {"type": "inactive_students", "data": result, "days": days}
        
        elif query_type == "event_list":
            # List all events
            query = """
                SELECT e.title, e.event_date, e.location, e.is_active, e.created_at,
                       u.name as organizer_name
                FROM events e
                LEFT JOIN users u ON e.organizer_id = u.id
                WHERE e.is_active = true
                ORDER BY e.event_date DESC
                LIMIT 30
            """
            
            from app.ai_assistant.manager import mcp_supabase_execute_sql
            result = await mcp_supabase_execute_sql(query)
            
            return {"type": "event_list", "data": result}
        
        elif query_type == "upcoming_events":
            # Upcoming events
            query = """
                SELECT e.title, e.event_date, e.location, u.name as organizer_name
                FROM events e
                LEFT JOIN users u ON e.organizer_id = u.id
                WHERE e.event_date >= CURRENT_DATE AND e.is_active = true
                ORDER BY e.event_date ASC
                LIMIT 20
            """
            
            from app.ai_assistant.manager import mcp_supabase_execute_sql
            result = await mcp_supabase_execute_sql(query)
            
            return {"type": "upcoming_events", "data": result}
        
        elif query_type == "department_stats":
            # Department statistics
            query = """
                SELECT u.department, 
                       COUNT(*) as total_students,
                       COUNT(CASE WHEN p.is_profile_complete = true THEN 1 END) as completed_profiles,
                       ROUND(COUNT(CASE WHEN p.is_profile_complete = true THEN 1 END) * 100.0 / COUNT(*), 2) as completion_rate
                FROM users u
                LEFT JOIN profiles p ON u.id = p.user_id
                WHERE u.role = 'student' AND u.department IS NOT NULL
                GROUP BY u.department
                ORDER BY total_students DESC
            """
            
            from app.ai_assistant.manager import mcp_supabase_execute_sql
            result = await mcp_supabase_execute_sql(query)
            
            return {"type": "department_stats", "data": result}
        
        elif query_type == "system_analytics":
            # Comprehensive system analytics
            queries = {
                "users": "SELECT role, COUNT(*) as count FROM users GROUP BY role",
                "events": "SELECT COUNT(*) as total, COUNT(CASE WHEN is_active = true THEN 1 END) as active FROM events",
                "profiles": "SELECT COUNT(*) as total, COUNT(CASE WHEN is_profile_complete = true THEN 1 END) as complete FROM profiles"
            }
            
            results = {}
            
            for key, query in queries.items():
                results[key] = await self._execute_mcp_sql(query)
            
            return {"type": "system_analytics", "data": results}
        
        return {"type": "unknown", "data": []}

    async def _execute_mcp_sql(self, query: str) -> list[dict[str, Any]]:
        """Execute SQL using MCP Supabase - simulated for now"""
        
        # For now, use our existing service bridge for database queries
        # In future, this will use actual MCP Supabase tools
        try:
            log.info(f"🔍 Executing MCP SQL: {query[:100]}...")
            
            # Use service bridge as proxy until MCP integration is complete
            # This simulates what MCP would do - execute raw SQL and return results
            from sqlalchemy import text
            raw_result = self._service_bridge.db.execute(text(query)).fetchall()
            
            # Convert SQLAlchemy result to dict format (like MCP would return)
            results = []
            for row in raw_result:
                row_dict = {}
                for i, column in enumerate(row._fields if hasattr(row, '_fields') else row.keys()):
                    row_dict[column] = row[i]
                results.append(row_dict)
            
            log.info(f"📊 MCP SQL returned {len(results)} results")
            return results
            
        except Exception as e:
            log.error(f"MCP SQL execution failed: {e}")
            return []

    def _format_admin_db_response(
        self, 
        result: dict[str, Any], 
        original_query: str
    ) -> schemas.AICommandResponse:
        """Format database results for admin consumption"""
        
        query_type = result["type"]
        data = result["data"]
        
        if query_type == "student_list":
            if not data:
                message = "📋 **Student List**: No students found matching criteria."
            else:
                filters = result.get("filters", {})
                filter_text = ""
                if filters:
                    filter_parts = []
                    if filters.get("department"):
                        filter_parts.append(f"Department: {filters['department']}")
                    if filters.get("is_active") is not None:
                        filter_parts.append(f"Status: {'Active' if filters['is_active'] else 'Inactive'}")
                    filter_text = f" ({', '.join(filter_parts)})" if filter_parts else ""
                
                message = f"👥 **Student List{filter_text}** - {len(data)} students found:\n\n"
                
                for i, student in enumerate(data[:15], 1):
                    status = "🟢" if student.get('is_active') else "🔴"
                    message += f"{i}. {status} **{student.get('name', 'N/A')}**\n"
                    message += f"   📧 {student.get('email', 'N/A')}\n"
                    message += f"   🏢 {student.get('department', 'N/A')}\n"
                    if student.get('student_id'):
                        message += f"   🆔 {student['student_id']}\n"
                    message += f"   📅 Joined: {student.get('created_at', 'N/A')[:10] if student.get('created_at') else 'N/A'}\n\n"
                
                if len(data) > 15:
                    message += f"... and {len(data) - 15} more students"
        
        elif query_type == "incomplete_profiles":
            if not data:
                message = "✅ **Great News!** All students have completed their profiles."
            else:
                message = f"⚠️ **Students with Incomplete Profiles** - {len(data)} students need attention:\n\n"
                
                for i, student in enumerate(data[:10], 1):
                    days_since = ""
                    if student.get('created_at'):
                        from datetime import datetime, timezone
                        created = datetime.fromisoformat(student['created_at'].replace('Z', '+00:00'))
                        days = (datetime.now(timezone.utc) - created).days
                        days_since = f" ({days} days ago)"
                    
                    message += f"{i}. **{student.get('name', 'N/A')}**\n"
                    message += f"   📧 {student.get('email', 'N/A')}\n"
                    message += f"   🏢 {student.get('department', 'N/A')}\n"
                    message += f"   📅 Registered: {student.get('created_at', 'N/A')[:10] if student.get('created_at') else 'N/A'}{days_since}\n\n"
                
                if len(data) > 10:
                    message += f"... and {len(data) - 10} more students"
        
        elif query_type == "event_list":
            if not data:
                message = "📅 **No events found** in the system."
            else:
                message = f"📅 **Event List** - {len(data)} events:\n\n"
                
                for i, event in enumerate(data[:10], 1):
                    event_date = event.get('event_date', 'N/A')
                    if event_date and event_date != 'N/A':
                        event_date = event_date[:10]  # Format date
                    
                    message += f"{i}. **{event.get('title', 'N/A')}**\n"
                    message += f"   📅 Date: {event_date}\n"
                    message += f"   📍 Location: {event.get('location', 'N/A')}\n"
                    if event.get('organizer_name'):
                        message += f"   👤 Organizer: {event['organizer_name']}\n"
                    message += "\n"
                
                if len(data) > 10:
                    message += f"... and {len(data) - 10} more events"
        
        elif query_type == "department_stats":
            if not data:
                message = "📊 **No department data available.**"
                else:
                message = f"🏢 **Department Statistics** - {len(data)} departments:\n\n"
                
                total_students = sum(dept.get('total_students', 0) for dept in data)
                total_completed = sum(dept.get('completed_profiles', 0) for dept in data)
                overall_rate = round((total_completed / total_students * 100), 1) if total_students > 0 else 0
                
                message += f"**Overall**: {total_students} students, {overall_rate}% profile completion\n\n"
                
                for dept in data:
                    rate = dept.get('completion_rate', 0)
                    rate_emoji = "🟢" if rate >= 80 else "🟡" if rate >= 60 else "🔴"
                    
                    message += f"{rate_emoji} **{dept.get('department', 'N/A')}**\n"
                    message += f"   👥 Students: {dept.get('total_students', 0)}\n"
                    message += f"   ✅ Completed: {dept.get('completed_profiles', 0)}\n"
                    message += f"   📊 Rate: {rate}%\n\n"
        
        elif query_type == "system_analytics":
            analytics = data
            
            # User stats
            user_stats = {item['role']: item['count'] for item in analytics.get('users', [])}
            
            # Event stats
            event_stats = analytics.get('events', [{}])[0] if analytics.get('events') else {}
            
            # Profile stats
            profile_stats = analytics.get('profiles', [{}])[0] if analytics.get('profiles') else {}
            
            message = f"📊 **System Analytics Dashboard**\n\n"
            message += f"**👥 Users:**\n"
            message += f"   👨‍🎓 Students: {user_stats.get('student', 0)}\n"
            message += f"   👨‍🏫 Lecturers: {user_stats.get('lecturer', 0)}\n"
            message += f"   👤 Admins: {user_stats.get('admin', 0)}\n"
            message += f"   📊 Total: {sum(user_stats.values())}\n\n"
            
            message += f"**📅 Events:**\n"
            message += f"   📋 Total: {event_stats.get('total', 0)}\n"
            message += f"   ✅ Active: {event_stats.get('active', 0)}\n\n"
            
            if profile_stats:
                completion_rate = round((profile_stats.get('complete', 0) / profile_stats.get('total', 1)) * 100, 1) if profile_stats.get('total', 0) > 0 else 0
                message += f"**👤 Profiles:**\n"
                message += f"   📋 Total: {profile_stats.get('total', 0)}\n"
                message += f"   ✅ Complete: {profile_stats.get('complete', 0)}\n"
                message += f"   📊 Completion Rate: {completion_rate}%\n"
        
        else:
            message = f"✅ **Query executed successfully**\n\nQuery type: {query_type}\nResults: {len(data) if isinstance(data, list) else 'N/A'} records"
                
                return schemas.AICommandResponse(
                    success=True,
                    message=message,
                    source=schemas.AISource.OPENROUTER,
                    data={
                "query_type": "admin_database",
                "original_query": original_query,
                "results": data,
                "admin_only": True,
                "mcp_powered": True
            },
            steps=[
                schemas.AICommandStep(
                    label="🔐 Admin Database Access",
                    detail=f"Executed {query_type} query using MCP Supabase"
                ),
                schemas.AICommandStep(
                    label="📊 Data Processing", 
                    detail=f"Formatted {len(data) if isinstance(data, list) else 'complex'} results for admin view"
                )
            ]
        )

    async def _call_openrouter(
        self,
        command: str,
        context: dict[str, Any] | None,
    ) -> schemas.AICommandResponse | None:
        if not self._openrouter_client:
            return None

        # Use user specified model
        model = "qwen/qwen3-30b-a3b:free"

        # Try to get system data but don't worry if it fails
        try:
            system_stats = self._service_bridge.get_system_stats()
            db_status = "available" if not system_stats.get('error') else "maintenance"
        except Exception:
            system_stats = {}
            db_status = "maintenance"
        
        messages = [
            {
                "role": "system",
                "content": f"""You are a friendly AI assistant for UTHM (Universiti Tun Hussein Onn Malaysia) dashboard in Malaysia. 

PERSONALITY & TONE:
- Be conversational, friendly, and use Gen Z tone
- Mix English and Bahasa Malaysia naturally (like Malaysian Gen Z)
- Use emojis appropriately but don't overdo
- Be helpful but not overly formal
- Sound like a knowledgeable student buddy helping out

CONTEXT:
- You help with UTHM dashboard system queries and general assistance
- Database status: {db_status}
- System has {system_stats.get('total_users', 'some')} users ({system_stats.get('user_breakdown', {}).get('students', 'several')} students)
- Current time: {datetime.now().isoformat()}

IMPORTANT:
- Always respond naturally, like you're chatting with a friend
- Never mention technical limitations, API quotas, or error codes
- If database is in "maintenance", just say you'll help with general info instead
- Focus on being helpful and conversational

Respond in a natural, helpful way to: {command}"""
            },
            {
                "role": "user",
                "content": command
            }
        ]

        try:
            if not self._openrouter_client:
                self._openrouter_client = OpenRouterClient(api_key=self.settings.openrouter_api_key)

            response_text = await self._openrouter_client.chat_completion(
                model=model,
                messages=messages,
                max_tokens=800,
                temperature=0.7
            )

            # Return raw content as conversational message
            return schemas.AICommandResponse(
                success=True,
                message=response_text,
                source=schemas.AISource.OPENROUTER,
                data={
                    "model": model,
                    "mode": "conversational",
                    "database_status": db_status
                },
            )

        except Exception as e:
            log.error(f"OpenRouter error: {e}")
            return None

    def _attach_quota(self, response: schemas.AICommandResponse) -> schemas.AICommandResponse:
        """Attach quota information to response."""
        response.data = response.data or {}
        response.data["quota"] = {
            "daily_usage": self.daily_usage,
            "daily_limit": self.settings.openrouter_daily_limit,
            "usage_date": self._usage_date.isoformat(),
        }
        return response

    def _reset_usage_if_needed(self) -> None:
        """Reset usage counter if we've moved to a new day."""
        today = date.today()
        if today != self._usage_date:
            self.daily_usage = 0
            self._usage_date = today
